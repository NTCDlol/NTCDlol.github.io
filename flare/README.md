# Flare — Язык

Flare — это динамический язык программирования, вдохновленный Python, Java, C и ASM. Он предназначен для создания мощных приложений, которые могут работать как на уровне пользователя, так и на уровне системы. Flare сочетает динамичность, строгий контроль над памятью и поддержку архитектурных особенностей работы с бинарными данными.

---

## Основные возможности Flare

- Динамическая типизация переменных и функций
- Автоматическое или ручное управление памятью (FlameMemory / ManualMemory)
- Работа с бинарными числами (с разной битностью и архитектурой, включая arm64)
- Поддержка виртуальной памяти
- Подключение модулей и библиотек из официального репозитория Fire
- Гибкий синтаксис: статический и динамический режимы
- Расширяемость через собственные библиотеки и модули

---

## Память в Flare

Flare имеет два режима работы с памятью:

### FlameMemory (Динамический режим)

FlameMemory — это система автоматического управления памятью в динамическом режиме Flare.

---

#### Поведение FlameMemory

- При включённой динамике (`dynamic = true`), FlameMemory автоматически освобождает ненужные переменные и структуры, освобождая оперативную память.
- FlameMemory выбрасывает все объекты, которые более не используются, обеспечивая быструю и стабильную работу.

---

#### Управление FlameMemory

- `searmem = true/false`  
  Если `true`, при потере значения переменной FlameMemory будет читать скрипт, чтобы попытаться восстановить переменную.  
  Если `false`, будет сразу ошибка об отсутствии переменной.  
  При больших проектах рекомендуется устанавливать `searmem = false` для ускорения выполнения.

- `link {название переменной}`  
  Фиксация переменной в памяти: переменная останется в памяти, пока не закончится её активное использование или время.

- `back(номер_строки, true/false)`  
  Переход на определённую строку скрипта.  
  `true` — продолжить выполнение после возврата.  
  `false` — не продолжать, а выполнить возврат и остановить текущую последовательность.

---

#### Команды управления FlameMemory

| Команда | Назначение |
|:--------|:-----------|
| `searmem = true/false` | Автоматический поиск потерянных переменных |
| `link {переменная}` | Зафиксировать переменную в памяти |
| `back(строка, true/false)` | Перезапуск/переход к строке скрипта |

---

#### Переменная активации FlameMemory

- `act.flmmem = true/false`

Управляет включением или выключением работы FlameMemory.

- В динамическом режиме (`dynamic = true`) по умолчанию `act.flmmem = true`.
- В статическом режиме (`dynamic = false`) по умолчанию `act.flmmem = false`.

Переключение вручную позволяет:
- Включить FlameMemory даже в статическом режиме для тестов или особых случаев.
- Отключить FlameMemory в динамическом режиме для полного контроля памяти.

Пример:

```
act.flmmem = false  // Полностью отключить FlameMemory даже при dynamic = true
```
#### Особенности

- Если включён `searmem = true`, FlameMemory пытается «починить» скрипт при потере данных, что удобно для небольших проектов.
- Если `searmem = false`, ошибки о потерях переменных возникают сразу для ускорения работы.
- `link` даёт возможность вручную управлять временем жизни переменных без полного контроля памяти.
- `back` позволяет пересоздавать переменные без необходимости постоянного хранения их в памяти.

---

### ManualMemory (Статический режим)

- Включается установкой `dynamic = false`
- Программист сам обязан освобождать память
- Полный контроль над выделением, использованием и освобождением памяти

### Команды управления памятью

- `mem(описание, размер в байтах/auto, ID)`  
  Выделение памяти для задачи.

- `virmem(описание, размер в байтах/auto, ID)`  
  Выделение виртуальной памяти для задач при нехватке обычной памяти.

- `frmem(ID, режим)`  
  Освобождение памяти:
  - `0` — обычный режим
  - `1` — аварийный режим
  - `2` — экстренное быстрое освобождение

- `int.ALLMEM`  
  Статичная переменная, показывающая общий объём доступной оперативной памяти (в байтах).

Пример:

```
mem(x = 1, auto, 1)
virmem(y = 2, auto, 2)
frmem(1, 2)
frmem(2, 0)
```

---

## Переменные

### Статический режим

Переменные объявляются с указанием типа:

```
str.name = "Hello"
int.x = 5
fl.y = 3.14
bin.16.value = 0xFFFF
ls.data = [1, 2, 3]
act.flag = true
```

### Динамический режим

Тип переменной определяется автоматически:

```
name = "Hello"
x = 5
y = 3.14
value = 0xFFFF
data = [1, 2, 3]
flag = true
```

---

## Вывод

В Flare вывод информации осуществляется следующим образом:

- При отсутствии библиотеки Flare.ALL используется только `video++`, где за раз можно выводить **только один символ**.

Пример:

```
str.video++ = "H"
str.video++ = "i"
```
 
- При подключении Flare.ALL появляется команда `out("текст")` для полноценного вывода строк.

---

## Условия

- Статический режим:

```
if (x > 10) {
    // код
}
```

- Динамический режим:

```
if x > 10:
    // код
```

---

## Циклы

- Статический режим:

```
for (int i = 0; i < 10; i++) {
    // код
}
```

- Динамический режим:

```
for i = 0 to 10:
    // код
```

---

## Функции

Функции требуют указания архитектуры или битности:

- Статический режим:

```
prog sum(a, b) f32 {
    return a + b
}
```

- Динамический режим:

```
prog sum(a, b) f32:
    return a + b
```

Функции завершаются либо `return`, либо `stop`.

---

## Управление ошибками и завершением

- `err("текст ошибки")` — генерация ошибки, завершение программы.
- `warn("текст предупреждения")` — вывод предупреждения без остановки выполнения.
- `allstop` — аварийная остановка выполнения блока кода.

---

## Дополнительные базовые команды

Flare в минимальной конфигурации без библиотек также предоставляет:

- `arch()` — возвращает установленную архитектуру или битность (`str.bitarch`).
- `flver()` — возвращает версию интерпретатора Flare.
- `clsdef()` — возвращает список всех глобально определённых классов.

Эти команды помогают организовать базовый контроль над состоянием скрипта и используемыми структурами.

---

## Библиотеки

Они очень важны в Flare.
### Подключение библиотек

- Подключение библиотеки:

```
add Flare.MATH
```

- Подключение конкретного модуля:

```
from Flare.MATH add sqrt
```

- Подключение библиотеки с псевдонимом:

```
add Flare.MATH name math
```

### Стандартные библиотеки:

- **Flare.ALL** — Базовые функции Flare
- **Flare.MATH** — Математические операции
- **Flare.OSAF** — Работа с файлами и ОС
- **Flare.EX** — Работа с внешними процессами
- **Flare.NET** — Работа с сетью
- **Flare.VIDAGPU** — Графика и работа с GPU
- **Flare.AI** — Работа с ИИ и Неиросетями. Требуется Flare.MATH
- **Flare.TIME** — Работа со временем.

### Схема библеотек:


```
libs/
|- Flare.flib (на самом деле это zip архив)
|- и другие библеотеки но уже стороние
|- libs.flrh — Список библиотек
```

```
Flare.flib (на самом деле это zip архив)/
|- MATH.flrs
|- OSAF.flrs
|- EX.flrs
|- NET.flrs
|- VIDAGPU.flrs
|- TIME.flrs
|- AI.flrs
|- ALL.flrs
|- libs.flrh — Обозначение какие библеотеки добавлять если добавляют все сразу
```

Из них можно забирать так же команды (все команды (или часть) должны быть в class видах)

---

## Форматы файлов Flare

- `.flrs` — Скрипты Flare
- `.flib` — Библиотеки Flare (архивы)
- `.flmod` — Отдельные модули Flare (архивы)
- `.flrh` — Заголовочные файлы библиотек и модулей Flare

---

## Пример скрипта Flare

```
dynamic = true

add Flare.MATH

x = 5
y = 2.5
z = x + y

if z > 6:
    warn("Значение z превышает 6")

prog add(a, b) f32:
    return a + b

ls.data = [1, 2, 3, 4]

mem("Работа со списком", auto, 0)

allstop
```